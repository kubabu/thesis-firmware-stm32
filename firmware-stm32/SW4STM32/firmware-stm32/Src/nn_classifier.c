/*
 * nn_classifier.c
 *
 *  Created on: Sep 4, 2017
 *      Author: kuba
 */

#include <stdio.h>
#include "classifiers.h"

#define OUT_CHANNELS 3
#define KERNEL_SIZE 5
#define POOL_SIZE 5
#define AFTER_POOL_LEN (SEQ_LEN / POOL_SIZE)
#define FULLY_CONNECTED 30
#define NUM_CLASSES 13


const char *nn_gesture_names[NUM_CLASSES] = {
	"circle_ccw", "circle_cw", "halt", "none", "pull_back", "push_forward", "roman_salute", "slide_down", "slide_left", "slide_right", "slide_up", "square_ccw", "square_cw"
};

const float means[FEATURES] = {
	0.17555f, -0.18073f, 0.79165f, -2.28101f, -0.89324f, -1.52014f, 38.85044f, -10.93265f, 11.13152f, -6.37378f, -13.42688f, 11.13093f
};

const float stdevs[FEATURES] = {
	0.29164f, 0.36636f, 0.32567f, 60.61109f, 29.97701f, 23.87586f, 15.83641f, 22.79118f, 19.16891f, 104.89758f, 33.14462f, 19.20330f
};

const float kernel[OUT_CHANNELS][FEATURES][KERNEL_SIZE] = {
	{
		{-0.24620f, -0.27219f, -0.25665f, -0.43122f, -0.35517f	},
		{-0.28275f, -0.32636f, -0.31831f, -0.23935f, -0.26316f	},
		{0.40648f, 0.30001f, 0.28957f, 0.31157f, 0.27420f	},
		{0.24235f, 0.34319f, -0.06346f, -0.12382f, -0.23697f	},
		{-0.18059f, 0.23678f, 0.24504f, -0.08680f, 0.09088f	},
		{0.50201f, 0.51252f, 0.35871f, -0.57431f, -0.28763f	},
		{0.23988f, 0.16009f, 0.39742f, 0.18613f, 0.27381f	},
		{-0.40980f, -0.22536f, -0.14849f, -0.17532f, -0.29631f	},
		{-0.35718f, -0.22804f, -0.37161f, -0.24375f, -0.42046f	},
		{0.03551f, 0.00216f, 0.10249f, 0.12553f, -0.02270f	},
		{-0.27589f, -0.19572f, -0.35945f, -0.23673f, -0.27455f	},
		{-0.31588f, -0.28560f, -0.39270f, -0.22580f, -0.24509f	}
},
	{
		{0.38030f, 0.28774f, 0.52843f, 0.52200f, 0.31358f	},
		{-0.31907f, -0.15158f, -0.19171f, -0.37723f, -0.36261f	},
		{0.09280f, -0.02672f, 0.15801f, 0.43498f, 0.16714f	},
		{-0.24327f, -0.38115f, -0.27569f, -0.24808f, -0.34148f	},
		{-0.74113f, -0.12391f, -0.05214f, 0.00497f, 0.31611f	},
		{0.04548f, 0.58863f, 0.57181f, 0.24557f, -0.08846f	},
		{-0.05191f, -0.01709f, -0.05282f, 0.10623f, 0.05945f	},
		{-0.21326f, 0.00448f, -0.17571f, -0.19494f, -0.38296f	},
		{0.30129f, 0.37183f, 0.30307f, 0.32691f, 0.42487f	},
		{0.17752f, 0.20053f, 0.08884f, 0.07808f, 0.14842f	},
		{-0.22071f, -0.03503f, -0.23994f, -0.21525f, -0.32008f	},
		{0.17825f, 0.40272f, 0.35744f, 0.30067f, 0.34905f	}
},
	{
		{0.07283f, -0.08396f, 0.20427f, 0.19811f, 0.14618f	},
		{0.58506f, 0.37729f, 0.36509f, 0.59082f, 0.55478f	},
		{-0.62205f, -0.48175f, -0.53831f, -0.38517f, -0.36065f	},
		{0.09728f, -0.14090f, -0.13629f, 0.07986f, 0.00176f	},
		{-0.50737f, -0.77676f, -0.54748f, -0.04590f, 0.35496f	},
		{-0.23323f, -0.66064f, -0.61435f, -0.29459f, 0.00246f	},
		{-0.32093f, -0.33804f, -0.47345f, -0.16820f, -0.06562f	},
		{0.44852f, 0.19545f, 0.47704f, 0.49158f, 0.52759f	},
		{0.03318f, 0.24032f, 0.43100f, 0.41603f, 0.30304f	},
		{-0.10566f, -0.08539f, -0.04719f, -0.09030f, -0.12607f	},
		{0.43099f, 0.42288f, 0.53889f, 0.47793f, 0.62514f	},
		{0.20001f, 0.09522f, 0.39875f, 0.23960f, 0.22075f	}
}
};

const float bias[OUT_CHANNELS] = {
	0.22193f,0.35881f,-0.17998f
};


float output[OUT_CHANNELS][SEQ_LEN] = {{0.0f}};

float pool_output[OUT_CHANNELS][AFTER_POOL_LEN] = {{0.0f}};

float relu_output[OUT_CHANNELS][AFTER_POOL_LEN] = {{0.0f}};

float fc_output[NUM_CLASSES]= {0.0f};

const int gesture = -1;


const float fc[NUM_CLASSES][FULLY_CONNECTED] = {
	{-0.43670f, -0.36389f, 0.05942f, -0.24332f, -0.04204f, 0.19770f, 0.13496f, -0.11209f, -0.20373f, -0.46422f, -0.79670f, -0.43871f, 0.53896f, -0.16196f, 0.08885f, 0.43779f, -0.07559f, 0.21104f, -0.40512f, -0.58237f, -0.30474f, 0.74920f, 0.09805f, -0.21252f, 0.22126f, -0.11426f, 0.12239f, -0.12968f, -0.38695f, 0.38101f},
	{-0.15431f, -0.51597f, -0.58234f, -0.12516f, 0.36474f, 0.25804f, 0.56133f, -0.09419f, -0.05937f, -0.39580f, -0.50575f, -0.27954f, -0.52416f, 0.22816f, 0.58237f, 0.01016f, -0.03059f, -0.39482f, -0.29038f, -0.07035f, -0.32925f, -0.09429f, -0.00326f, -0.30422f, -0.00626f, 0.57937f, -0.07099f, 0.43385f, -0.24711f, -0.55240f},
	{-0.11014f, -0.28619f, -0.14056f, -0.49586f, -0.39710f, -0.21244f, -0.14514f, -0.09433f, -0.17949f, -0.17744f, -0.32441f, -0.42740f, -0.15878f, 0.00611f, -0.24903f, -0.11670f, -0.26376f, -0.13542f, 0.03874f, 0.02576f, -0.55671f, -0.18396f, -0.46515f, 0.12520f, -0.03740f, -0.04677f, 0.10938f, 0.26233f, 0.30515f, 0.19014f},
	{0.34227f, 0.34353f, 0.22200f, 0.08654f, 0.17893f, 0.24361f, 0.03471f, -0.09623f, 0.19557f, -0.03188f, 0.35344f, 0.06842f, 0.13561f, 0.36834f, -0.03901f, 0.02288f, -0.01892f, -0.13229f, -0.07349f, -0.03701f, 0.32274f, 0.04769f, 0.04564f, 0.06672f, -0.05333f, -0.15773f, -0.02497f, 0.03447f, 0.14573f, 0.17938f},
	{-0.25540f, -0.19754f, -0.48426f, -0.10381f, 0.48305f, 0.52735f, 0.48781f, 0.26188f, -0.32583f, -0.30238f, -0.49003f, -0.20021f, -0.15125f, -0.27044f, -0.52948f, 0.48243f, -0.31303f, -0.02350f, -0.06072f, 0.66124f, -0.37991f, 0.12890f, -0.60387f, -0.61884f, 0.35282f, -0.29369f, 0.08155f, -0.16061f, 0.04885f, -0.16662f},
	{-0.32176f, -0.31750f, -0.17010f, -0.29872f, -0.46510f, -0.11444f, -0.04927f, 0.31794f, 0.06705f, 0.28387f, -0.03128f, 0.20480f, 0.07118f, -0.21656f, 0.37019f, 0.28224f, -0.00101f, 0.15281f, -0.40101f, -0.48818f, -0.02255f, 0.04157f, 0.46413f, -0.11205f, -0.09579f, -0.16435f, 0.11978f, 0.11079f, 0.03822f, -0.73858f},
	{-0.36512f, -0.06413f, -0.31124f, -0.34665f, -0.17869f, 0.01966f, -0.13590f, -0.28827f, -0.17619f, -0.45415f, -0.15185f, 0.00754f, -0.21980f, -0.22710f, -0.16000f, -0.06491f, 0.18658f, -0.06125f, 0.40967f, 0.26820f, -0.40862f, -0.37798f, -0.48708f, -0.32860f, -0.27166f, -0.27533f, 0.04267f, -0.02666f, 0.38233f, 0.17936f},
	{-0.19707f, -0.05842f, -0.35963f, -0.22012f, -0.08997f, -0.15483f, -0.04014f, 0.01011f, 0.62906f, 0.70309f, -0.20850f, -0.34941f, -0.14534f, -0.20869f, -0.04844f, -0.03804f, -0.20690f, -0.28792f, -0.27055f, -0.25692f, -0.25358f, -0.17261f, 0.09848f, -0.01806f, -0.15759f, -0.18403f, -0.26578f, -0.25476f, 0.01219f, -0.06968f},
	{-0.23570f, -0.31668f, -0.31486f, -0.16992f, -0.05086f, -0.35690f, -0.13236f, -0.20119f, -0.17757f, -0.33569f, -0.27760f, -0.28261f, -0.26930f, -0.09554f, 0.14398f, -0.35009f, -0.56522f, -0.45523f, -0.53153f, -0.44557f, -0.09240f, -0.48796f, -0.01819f, -0.32499f, -0.12055f, -0.25107f, 0.08548f, 0.17325f, 0.25756f, 0.62183f},
	{-0.15954f, -0.20494f, -0.23984f, -0.32363f, -0.24583f, -0.14912f, -0.12655f, 0.08171f, 0.07250f, 0.00990f, -0.19283f, -0.38674f, -0.14674f, -0.27926f, -0.29798f, -0.25513f, 0.21147f, 0.43653f, 0.21390f, 0.15420f, 0.16283f, 0.11005f, 0.20575f, 0.02271f, -0.03766f, -0.08861f, -0.29144f, -0.30123f, -0.27882f, -0.46340f},
	{-0.09614f, -0.22373f, -0.23761f, -0.28580f, -0.37205f, -0.34181f, -0.16743f, 0.00010f, -0.46635f, -0.28433f, -0.17065f, -0.30521f, -0.38293f, -0.41453f, -0.37010f, -0.29146f, 0.13937f, 0.40950f, 0.36906f, 0.49979f, -0.12431f, -0.17207f, 0.05749f, -0.01142f, -0.09278f, -0.24994f, -0.21149f, -0.32481f, 0.04524f, 0.11268f},
	{-0.14180f, -0.46133f, 0.11748f, 0.01539f, 0.08755f, 0.10553f, -0.37863f, -0.34041f, -0.34666f, -0.41936f, -0.34659f, -0.57175f, -0.47780f, -0.41901f, -0.02892f, -0.57683f, -0.46562f, 0.02746f, 0.10854f, -0.15689f, -0.52835f, 0.33170f, -0.07565f, 0.70192f, -0.02859f, 0.14331f, 0.39784f, 0.19411f, 0.07381f, -1.01225f},
	{-0.47475f, -0.56945f, -0.32075f, -0.30996f, -0.32401f, -0.35509f, 0.18952f, -0.46668f, 0.09159f, 0.52776f, -0.22838f, 0.34421f, -0.18262f, -0.37725f, -0.33777f, 0.66055f, -0.09644f, -0.60475f, -0.34284f, -0.53318f, -0.21195f, 0.01692f, 0.65057f, 0.22519f, 0.01342f, 0.16892f, -0.02507f, 0.29585f, -0.73298f, -0.51261f}
};

 float fc_bias[NUM_CLASSES] = {
	-0.17168f, -0.18517f, -0.20427f, 0.30520f, 0.03094f, -0.00296f, 0.08208f, -0.21081f, -0.29387f, -0.00612f, -0.33014f, -0.27115f, -0.46698f
};

const char* nn_get_name(int16_t code) {
    if(code < NUM_CLASSES) {
        return nn_gesture_names[code];
    }
    return "";
}

void nn_normalize(float *values, float *results) {
    for(int i = 0; i < FEATURES; ++i) {
        results[i] = (values[i] - means[i]) / stdevs[i];
    }
}

void print_seq(const char *name, const float *seq, int len)
{
    puts(name);
    for(int i = 0; i < len; i++)
    {
        printf("%.4f ", seq[i]);
    }

    putchar('\n');
}


float seq_max(const float *seq, int size)
{
    float max = seq[0];
    for(int i = 1; i < size; i++)
    {
        if(seq[i] > max)
        {
            max = seq[i];
        }
    }
    return max;
}

float argmax(const const float* seq, int size)
{
    int idx = 0;
    float max = seq[0];
    for(int i = 1; i < size; i++)
    {
        if(seq[i] > max)
        {
            max = seq[i];
            idx = i;
        }
    }
    return idx;

}


void normalize(float *values, float *results) {
    for(int i = 0; i < FEATURES; ++i) {
        results[i] = (values[i] - means[i]) / stdevs[i];
    }
}


int16_t nn_classifier(const float series[FEATURES][NN_SEQ_LEN])
{
    for(int c_idx = 0; c_idx < OUT_CHANNELS; c_idx++)
    {
        for(int s_idx = 0; s_idx < SEQ_LEN; s_idx++)
        {
            //puts("=====\n");
            for(int f_idx = 0; f_idx < FEATURES; f_idx++)
            {
                for(int k_idx = 0; k_idx < KERNEL_SIZE; k_idx++)
                {
                    float left = series[f_idx][s_idx + k_idx];
                    float right = kernel[c_idx][f_idx][k_idx];
                    //float orig = output[c_idx][s_idx];

                    output[c_idx][s_idx] += left * right;

                    //printf("%.1f + %.1f * %.1f = %.1f\n", orig, left,right, output[c_idx][s_idx]);
                }
            }

            // add bias term
            output[c_idx][s_idx] += bias[c_idx];

        }

        for(int i = 0; i < AFTER_POOL_LEN; i++)
        {
            // pointer arithmetic
            float val = seq_max(&(output[c_idx][i * POOL_SIZE]), POOL_SIZE);
            pool_output[c_idx][i] = val;
        }

        //relu

        for(int i = 0; i < AFTER_POOL_LEN; i++)
        {
            if(pool_output[c_idx][i] > 0)
            {
                relu_output[c_idx][i] = pool_output[c_idx][i];
            }
        }

        //print_seq("seq", relu_output[c_idx], AFTER_POOL_LEN);
        //putchar('\n');
    }

    for(int k = 0; k < NUM_CLASSES; k++)
    {
        for(int i = 0; i < FULLY_CONNECTED; i++)
        {
            int y = i / FULLY_CONNECTED;
            int x = i % FULLY_CONNECTED;
            float v = relu_output[y][x];
            fc_output[k] += fc[k][i] * v;
        }
        fc_output[k] += fc_bias[k];
    }
    //print_seq("out", fc_output, NUM_CLASSES);

    int g = argmax(fc_output, NUM_CLASSES);

    return g;
}
