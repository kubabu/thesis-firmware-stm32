/*
 * nn_classifier.c
 *
 *  Created on: Sep 4, 2017
 *      Author: kuba
 */

#include <stdio.h>

#include "classifiers.h"

#define OUT_CHANNELS 3
#define KERNEL_SIZE 5
#define POOL_SIZE 5
#define AFTER_POOL_LEN (SEQ_LEN / POOL_SIZE)
#define FULLY_CONNECTED 30
#define NUM_CLASSES 13


const char *GESTURE_NAMES[NUM_CLASSES] = {
	"circle_ccw", "circle_cw", "halt", "none", "pull_back", "push_forward", "roman_salute", "slide_down", "slide_left", "slide_right", "slide_up", "square_ccw", "square_cw"
};

const float means[FEATURES] = {
	0.17555f, -0.18073f, 0.79165f, -2.28101f, -0.89324f, -1.52014f, 38.85044f, -10.93265f, 11.13152f, -6.37378f, -13.42688f, 11.13093f
};

const float stdevs[FEATURES] = {
	0.29164f, 0.36636f, 0.32567f, 60.61109f, 29.97701f, 23.87586f, 15.83641f, 22.79118f, 19.16891f, 104.89758f, 33.14462f, 19.20330f
};

const float kernel[OUT_CHANNELS][FEATURES][KERNEL_SIZE] = {
	{
		{-0.32729f, -0.40274f, -0.25059f, -0.46013f, -0.49656f	},
		{-0.02488f, -0.02673f, -0.02883f, 0.18550f, 0.01010f	},
		{0.18032f, 0.25538f, 0.23530f, 0.13709f, -0.01726f	},
		{-0.09927f, 0.13141f, 0.17711f, 0.16154f, 0.13130f	},
		{0.61322f, 0.20419f, 0.38066f, 0.16297f, -0.17765f	},
		{0.58472f, 0.64337f, 0.07316f, -0.83666f, -0.83397f	},
		{0.20893f, 0.13394f, 0.10402f, 0.03876f, 0.09726f	},
		{-0.01765f, 0.02987f, -0.02405f, 0.14107f, 0.03792f	},
		{-0.54915f, -0.35312f, -0.39822f, -0.41430f, -0.48540f	},
		{0.07257f, 0.16003f, 0.07832f, 0.02360f, 0.15554f	},
		{0.13607f, 0.02568f, 0.02930f, 0.19688f, 0.18694f	},
		{-0.30402f, -0.54593f, -0.36169f, -0.52583f, -0.43891f	}
},
	{
		{0.49325f, 0.53819f, 0.41740f, 0.29276f, 0.31725f	},
		{-0.14438f, -0.17621f, -0.07434f, -0.19125f, 0.04499f	},
		{-0.12227f, -0.10232f, -0.09620f, -0.07916f, 0.05757f	},
		{0.34072f, -0.14842f, -0.15148f, 0.09523f, -0.00655f	},
		{-0.23080f, 0.17751f, 0.26457f, 0.30937f, 0.21220f	},
		{-0.22629f, -0.58493f, -0.43018f, -0.42799f, -0.29740f	},
		{0.03453f, 0.07827f, -0.06086f, 0.06028f, 0.20663f	},
		{-0.01804f, -0.15063f, -0.07440f, -0.15791f, -0.08800f	},
		{0.48354f, 0.56675f, 0.52722f, 0.48268f, 0.43095f	},
		{0.19703f, 0.37432f, 0.14020f, 0.29094f, 0.14707f	},
		{-0.13567f, -0.15471f, -0.14973f, -0.00660f, 0.17227f	},
		{0.40357f, 0.53215f, 0.48069f, 0.32237f, 0.18550f	}
},
	{
		{-0.02806f, -0.05272f, 0.06129f, 0.06651f, -0.11192f	},
		{-0.35144f, -0.29424f, -0.39129f, -0.22585f, -0.37771f	},
		{0.19168f, 0.06460f, 0.33545f, 0.20855f, 0.17476f	},
		{-0.55501f, -0.61765f, 0.12032f, 0.41469f, 0.54439f	},
		{-0.48373f, 0.09748f, -0.10711f, 0.44312f, 0.16876f	},
		{-0.21425f, 0.11400f, -0.34208f, -0.00185f, 0.21365f	},
		{0.22975f, -0.03003f, 0.24943f, 0.14158f, 0.13234f	},
		{-0.39080f, -0.26215f, -0.20398f, -0.19357f, -0.34691f	},
		{-0.17979f, -0.04751f, -0.01738f, 0.02620f, -0.21854f	},
		{0.00124f, -0.06872f, -0.05593f, 0.09600f, -0.06973f	},
		{-0.18903f, -0.30348f, -0.40848f, -0.23757f, -0.18854f	},
		{-0.04474f, -0.03246f, -0.12337f, -0.02850f, -0.13601f	}
}
};

const float bias[OUT_CHANNELS] = {
	0.15767f,0.24275f,0.35010f
};


float output[OUT_CHANNELS][SEQ_LEN] = {{0.0f}};

float pool_output[OUT_CHANNELS][AFTER_POOL_LEN] = {{0.0f}};

float relu_output[OUT_CHANNELS][AFTER_POOL_LEN] = {{0.0f}};

float fc_output[NUM_CLASSES]= {0.0f};

const int gesture = -1;


const float fc[NUM_CLASSES][FULLY_CONNECTED] = {
	{-0.06266f, 0.00224f, -0.26361f, 0.41309f, 0.00674f, 0.12299f, 0.04725f, -0.02989f, 0.06626f, -0.39217f, -0.40875f, -0.34617f, 0.38764f, 0.44743f, 0.08400f, 0.06955f, -0.09711f, -0.20157f, 0.08180f, -0.23507f, -0.43708f, -0.53537f, -0.48025f, 0.34251f, -0.57382f, -0.05765f, 0.10087f, 0.09299f, 0.02073f, -0.29348f},
	{0.21526f, -0.19833f, -0.44064f, -0.14261f, 0.34387f, -0.27515f, 0.51423f, -0.13380f, -0.32947f, -0.46917f, -0.10598f, -0.10349f, -0.19569f, -0.20829f, 0.24271f, 0.46650f, 0.31266f, 0.06752f, -0.61580f, -0.37992f, -0.10679f, -0.42363f, -0.37540f, -0.30285f, -0.04164f, -0.23482f, 0.36265f, 0.26880f, -0.28641f, -0.36965f},
	{0.04722f, -0.07008f, 0.24480f, 0.00844f, 0.04255f, -0.26632f, -0.36994f, -0.40951f, -0.20458f, -0.48994f, -0.27912f, -0.23885f, -0.18091f, 0.18471f, -0.08261f, -0.29266f, -0.14844f, 0.03138f, 0.21402f, 0.48889f, 0.17081f, -0.08559f, -0.13217f, -0.13853f, -0.13734f, -0.33956f, -0.29509f, -0.34979f, -0.24851f, -0.34693f},
	{0.17410f, 0.11350f, 0.11313f, 0.13067f, -0.06266f, 0.07437f, -0.16270f, 0.01248f, -0.08950f, -0.06660f, 0.18571f, 0.32854f, 0.14798f, 0.23984f, 0.13104f, -0.06643f, 0.07711f, -0.10770f, -0.02293f, -0.14244f, 0.47487f, 0.10338f, 0.14734f, 0.17906f, 0.37107f, 0.30859f, 0.28558f, 0.09849f, 0.09240f, 0.17398f},
	{-0.19623f, -0.18611f, -0.25897f, 0.21460f, 0.50850f, 0.16497f, 0.42149f, 0.32702f, -0.44738f, -1.00083f, -0.10769f, -0.02462f, -0.19918f, -0.23410f, -0.00651f, 0.02140f, 0.20261f, -0.06486f, -0.13906f, -0.10597f, -0.27122f, -0.01819f, -0.29369f, -0.21347f, -0.47700f, -0.17419f, -0.04439f, 0.03721f, 0.33616f, -0.14093f},
	{-0.53720f, -0.40560f, -0.53062f, -0.60249f, -0.59652f, 0.07488f, -0.13606f, 0.59674f, 0.39580f, 0.18436f, 0.09327f, 0.10218f, 0.18309f, 0.12283f, -0.02873f, 0.05440f, -0.04598f, -0.02300f, -0.04034f, -0.38771f, -0.33311f, -0.41070f, -0.45331f, -0.12038f, -0.13565f, -0.36295f, -0.69265f, -0.54257f, -0.29532f, 0.06261f},
	{-0.43120f, -0.36427f, -0.35248f, -0.48076f, -0.11319f, -0.12310f, 0.21693f, -0.16619f, -0.39764f, -0.49570f, 0.04558f, -0.17873f, -0.29701f, -0.23597f, -0.26553f, -0.18295f, 0.34159f, -0.39928f, 0.74407f, 0.39252f, -0.14769f, -0.21792f, -0.06188f, -0.01500f, -0.16721f, 0.15325f, -0.33003f, -0.34937f, -0.44349f, -0.29956f},
	{-0.39424f, -0.42194f, -0.00724f, -0.39884f, -0.21043f, -0.15140f, 0.25021f, 0.13888f, 0.14718f, 0.49941f, -0.36465f, -0.13026f, -0.16106f, -0.21950f, -0.20214f, -0.27739f, -0.44548f, -0.65820f, -0.54205f, -0.25233f, -0.50596f, -0.50478f, -0.14662f, -0.27285f, -0.26547f, -0.28237f, 0.03339f, 0.19554f, 0.42540f, 0.31334f},
	{-0.56505f, -0.16390f, -0.33221f, -0.47753f, -0.20778f, -0.16885f, 0.39627f, 0.28584f, 0.51536f, 0.20109f, -0.26156f, -0.26545f, -0.11714f, -0.20412f, 0.07613f, -0.06929f, -0.37522f, -0.31108f, -0.12087f, -0.09204f, -0.42429f, -0.17714f, -0.24170f, -0.25252f, 0.29937f, -0.27805f, -0.45937f, -0.29813f, -0.59565f, -0.30792f},
	{-0.08238f, -0.29925f, -0.34926f, -0.22531f, -0.20980f, -0.11368f, -0.22851f, 0.04365f, -0.24405f, -0.22281f, -0.11600f, -0.13604f, -0.14957f, -0.25424f, -0.19206f, -0.24975f, 0.00689f, 0.07791f, 0.17849f, -0.10804f, -0.29366f, -0.17235f, -0.16067f, -0.42760f, -0.37338f, -0.07529f, 0.10157f, 0.42976f, 0.54229f, 0.41943f},
	{0.01269f, -0.11179f, -0.11187f, -0.10201f, -0.10150f, -0.13311f, -0.04536f, -0.27029f, -0.23386f, -0.49826f, -0.20763f, -0.32159f, -0.18139f, -0.21709f, -0.13011f, -0.33350f, 0.03181f, -0.16160f, 0.24922f, 0.30750f, -0.51551f, -0.48757f, -0.15111f, -0.28216f, -0.31970f, -0.33126f, 0.28080f, 0.26175f, 0.35146f, -0.21281f},
	{0.03684f, -0.49286f, 0.71999f, 0.16385f, -0.14375f, 0.55287f, -0.54274f, -0.32284f, -0.09548f, 0.01419f, -0.32746f, -0.29260f, -0.23335f, -0.37230f, 0.43303f, -0.08799f, -0.03717f, -0.06108f, 0.18501f, -0.02634f, -0.63315f, -0.38138f, -0.50612f, -0.41733f, -0.42638f, -0.58951f, -0.28432f, -0.20546f, -0.46649f, -0.19390f},
	{0.09316f, -0.26776f, -0.19700f, -0.46470f, -0.04283f, -0.47878f, 0.29549f, -0.24969f, 0.12916f, 0.33117f, -0.99597f, 0.40092f, 0.36478f, 0.16227f, 0.14143f, 0.37731f, 0.05270f, -0.00661f, -0.51264f, -0.25867f, -0.60127f, -0.49794f, -0.42192f, -0.65403f, -0.24420f, -0.46527f, -0.14801f, -0.16027f, -0.10978f, -0.27407f}
};

 float fc_bias[NUM_CLASSES] = {
	0.24415f, -0.04383f, -0.36176f, 0.21578f, -0.18803f, -0.16367f, -0.01560f, -0.32787f, -0.35375f, -0.09983f, -0.25667f, -0.16974f, -0.20504f
};


const char* nn_get_name(int16_t code) {
 	if(code < NUM_CLASSES) {
 		return GESTURE_NAMES[code];
 	}
 	return "";
}


void print_seq(const char *name, const float *seq, int len)
{
    puts(name);
    for(int i = 0; i < len; i++)
    {
        printf("%.4f ", seq[i]);
    }

    putchar('\n');
}


float seq_max(const float *seq, int size)
{
    float max = seq[0];
    for(int i = 1; i < size; i++)
    {
        if(seq[i] > max)
        {
            max = seq[i];
        }
    }
    return max;
}

float argmax(const const float* seq, int size)
{
    int idx = 0;
    float max = seq[0];
    for(int i = 1; i < size; i++)
    {
        if(seq[i] > max)
        {
            max = seq[i];
            idx = i;
        }
    }
    return idx;

}

int16_t nn_classifier(const float series[FEATURES][PADDED_SEQ_LEN])
{
    for(int c_idx = 0; c_idx < OUT_CHANNELS; c_idx++)
    {
        for(int s_idx = 0; s_idx < SEQ_LEN; s_idx++)
        {
            //puts("=====\n");
            for(int f_idx = 0; f_idx < FEATURES; f_idx++)
            {
                for(int k_idx = 0; k_idx < KERNEL_SIZE; k_idx++)
                {
                    float left = series[f_idx][s_idx + k_idx];
                    float right = kernel[c_idx][f_idx][k_idx];
                    //float orig = output[c_idx][s_idx];

                    output[c_idx][s_idx] += left * right;

                    //printf("%.1f + %.1f * %.1f = %.1f\n", orig, left,right, output[c_idx][s_idx]);
                }
            }

            // add bias term
            output[c_idx][s_idx] += bias[c_idx];

        }

        for(int i = 0; i < AFTER_POOL_LEN; i++)
        {
            // pointer arithmetic
            float val = seq_max(&(output[c_idx][i * POOL_SIZE]), POOL_SIZE);
            pool_output[c_idx][i] = val;
        }

        //relu

        for(int i = 0; i < AFTER_POOL_LEN; i++)
        {
            if(pool_output[c_idx][i] > 0)
            {
                relu_output[c_idx][i] = pool_output[c_idx][i];
            }
        }

        //print_seq("seq", relu_output[c_idx], AFTER_POOL_LEN);
        //putchar('\n');
    }

    for(int k = 0; k < NUM_CLASSES; k++)
    {
        for(int i = 0; i < FULLY_CONNECTED; i++)
        {
            int y = i / FULLY_CONNECTED;
            int x = i % FULLY_CONNECTED;
            float v = relu_output[y][x];
            fc_output[k] += fc[k][i] * v;
        }
        fc_output[k] += fc_bias[k];
    }
    //print_seq("out", fc_output, NUM_CLASSES);

    int g = argmax(fc_output, NUM_CLASSES);

    return g;
}


void normalize(float *values, float *results) {
	for(int i = 0; i < FEATURES; ++i) {
		results[i] = (values[i] - means[i]) / stdevs[i];
	}
}
