/*
 * nn_classifier.c
 *
 *  Created on: Sep 4, 2017
 *      Author: kuba
 */

#include <stdio.h>

#include "classifiers.h"

#define OUT_CHANNELS 3
#define KERNEL_SIZE 5
#define POOL_SIZE 5
#define AFTER_POOL_LEN (SEQ_LEN / POOL_SIZE)
#define FULLY_CONNECTED 30
#define NUM_CLASSES 13


const float kernel[OUT_CHANNELS][FEATURES][KERNEL_SIZE] = {
    {
        {0.07469f, 0.01306f, -0.09686f, -0.01433f, -0.05688f },
        {0.09101f, -0.05792f, 0.11600f, -0.06796f, 0.09631f },
        {0.00716f, -0.02466f, -0.01103f, -0.17578f, -0.10909f },
        {-0.03620f, -0.06604f, 0.00773f, -0.00276f, -0.02953f },
        {0.07333f, 0.04548f, 0.00923f, 0.04616f, 0.15130f },
        {-0.22063f, -0.09685f, -0.25222f, 0.03581f, 0.10650f },
        {-0.05989f, -0.00772f, -0.02396f, -0.04465f, 0.04239f },
        {0.05097f, 0.10394f, -0.06036f, 0.05766f, 0.00918f },
        {-0.14683f, -0.08029f, -0.15785f, -0.20265f, -0.01719f },
        {-0.06531f, 0.02240f, 0.07542f, 0.09765f, 0.07055f },
        {0.09673f, 0.08074f, 0.10033f, 0.09237f, 0.11853f },
        {-0.01616f, -0.02234f, -0.07752f, -0.21435f, -0.10588f }
    },
    {
        {-0.02464f, 0.11584f, 0.04672f, -0.09319f, 0.06851f },
        {-0.10151f, -0.12166f, -0.05477f, -0.00691f, -0.05891f },
        {-0.07247f, -0.05891f, -0.15962f, -0.09226f, 0.10526f },
        {0.06138f, -0.07579f, -0.01303f, -0.01269f, -0.04561f },
        {-0.04796f, 0.11599f, -0.00442f, 0.07353f, 0.03449f },
        {0.01712f, -0.11444f, 0.15655f, -0.05438f, 0.13604f },
        {0.13360f, -0.05758f, 0.10876f, 0.03679f, -0.14241f },
        {0.01964f, -0.14388f, -0.20134f, 0.09086f, -0.08601f },
        {0.04824f, 0.05615f, -0.07407f, -0.11677f, 0.04190f },
        {-0.02775f, 0.05688f, 0.08783f, -0.01576f, -0.12314f },
        {-0.15461f, 0.04397f, -0.15758f, -0.02641f, -0.14766f },
        {-0.06503f, -0.02425f, -0.11255f, -0.03357f, 0.13703f }
    },
    {
        {-0.11550f, 0.10456f, 0.06512f, 0.06338f, 0.02679f },
        {-0.00950f, 0.16317f, -0.09128f, 0.00134f, 0.03768f },
        {0.00160f, -0.02298f, 0.02977f, 0.14772f, 0.18112f },
        {0.01867f, 0.01907f, 0.04328f, 0.06555f, 0.01135f },
        {-0.04595f, -0.07131f, -0.04271f, -0.02101f, -0.27058f },
        {0.00401f, -0.00423f, -0.03224f, -0.03074f, -0.00144f },
        {0.05236f, 0.09580f, 0.06387f, -0.11104f, 0.03251f },
        {0.00108f, 0.05608f, 0.10903f, -0.05768f, 0.15112f },
        {0.11000f, 0.11054f, 0.04379f, -0.01181f, 0.02807f },
        {-0.09375f, 0.09628f, 0.10638f, -0.09490f, 0.10416f },
        {-0.06183f, -0.07034f, -0.01853f, 0.12618f, 0.03799f },
        {0.06740f, 0.08231f, 0.13963f, -0.06226f, 0.01474f }
    }
};

const float bias[OUT_CHANNELS] = {

    0.07718f, 0.16852f, -0.03331f
};

float output[OUT_CHANNELS][SEQ_LEN] = {{0.0f}};

float pool_output[OUT_CHANNELS][AFTER_POOL_LEN] = {{0.0f}};

float relu_output[OUT_CHANNELS][AFTER_POOL_LEN] = {{0.0f}};

float fc_output[NUM_CLASSES]= {0.0f};

int gesture = -1;


const float fc[NUM_CLASSES][FULLY_CONNECTED] = {
    { -0.27157f, -0.25901f, -0.27163f, -0.00419f, -0.28523f, -0.08973f, -0.25379f, -0.03739f, -0.09657f, 0.13492f, -0.39082f, -0.38419f, 0.24636f, -0.12022f, 0.17143f, -0.00139f, 0.25600f, 0.07782f, 0.12302f, -0.46546f, -0.04627f, 0.32208f, -0.06370f, 0.07005f, 0.07226f, -0.06092f, 0.22740f, -0.06334f, -0.28071f, 0.05067f,  },
    { -0.18872f, 0.05562f, 0.00961f, -0.06847f, -0.00313f, 0.09037f, 0.08678f, 0.01209f, 0.09630f, -0.00478f, 0.02540f, -0.07124f, 0.03183f, 0.17415f, 0.03617f, 0.05817f, 0.06538f, 0.07932f, -0.14033f, 0.16115f, 0.11362f, 0.02805f, -0.15539f, 0.01944f, -0.04087f, 0.05532f, -0.09899f, -0.02275f, 0.04094f, 0.12847f,  },
    { -0.01587f, 0.08572f, 0.11292f, 0.24383f, -0.04665f, -0.06873f, 0.03768f, -0.10381f, 0.11157f, -0.08023f, -0.24490f, 0.05373f, -0.20566f, 0.02239f, -0.00142f, 0.04058f, 0.04021f, -0.15556f, -0.18347f, -0.36523f, -0.23964f, -0.10034f, -0.06193f, 0.06903f, -0.11670f, -0.00812f, 0.20481f, 0.16209f, -0.00949f, 0.12509f,  },
    { -0.07481f, 0.05444f, -0.08567f, 0.10783f, 0.11147f, -0.10130f, 0.00446f, -0.07566f, -0.08328f, 0.16273f, 0.08432f, 0.03041f, 0.01203f, 0.18371f, 0.16203f, -0.00789f, 0.07100f, 0.02732f, 0.02946f, 0.15253f, 0.08330f, 0.07278f, -0.03012f, -0.05254f, 0.02856f, 0.02220f, -0.00393f, 0.14457f, 0.04598f, 0.00958f,  },
    { 0.14803f, -0.13684f, -0.07483f, -0.02634f, 0.27846f, 0.01182f, 0.09621f, 0.00746f, 0.01719f, -0.25541f, -0.08849f, 0.06144f, -0.05466f, 0.02676f, -0.10968f, 0.05653f, 0.01483f, -0.07110f, 0.21969f, 0.16922f, 0.09923f, -0.08813f, 0.00814f, -0.05905f, -0.17514f, -0.08604f, 0.04220f, 0.11215f, 0.03543f, 0.11633f,  },
    { -0.02527f, -0.13636f, -0.14860f, -0.04709f, -0.06562f, 0.01284f, -0.02027f, -0.11628f, 0.14805f, 0.12114f, -0.14433f, 0.00710f, 0.02669f, -0.11315f, 0.10726f, -0.07199f, -0.12563f, 0.22728f, -0.04140f, 0.25594f, 0.20180f, 0.05815f, 0.12988f, -0.19662f, -0.00263f, -0.10567f, 0.16619f, -0.01978f, -0.02077f, -0.02026f,  },
    { 0.20980f, 0.01065f, 0.03013f, -0.01052f, -0.04622f, 0.02719f, -0.15189f, -0.22057f, -0.16828f, -0.24448f, -0.04740f, -0.05555f, 0.10964f, -0.02532f, 0.18808f, 0.04319f, -0.05138f, -0.11440f, -0.15407f, -0.00764f, 0.13755f, -0.19385f, -0.07534f, -0.21274f, -0.07972f, 0.04548f, 0.02558f, 0.13911f, 0.17271f, 0.17836f,  },
    { 0.00482f, -0.06383f, 0.06146f, 0.03289f, 0.08468f, 0.06629f, 0.04326f, 0.05095f, 0.13869f, 0.17648f, -0.02451f, -0.03497f, -0.17509f, -0.09904f, -0.04251f, 0.07894f, -0.07014f, -0.00026f, 0.15355f, 0.17763f, -0.07135f, -0.18752f, 0.03973f, -0.13146f, -0.08448f, 0.08275f, -0.02747f, 0.02928f, -0.05154f, 0.01691f,  },
    { 0.05539f, 0.05854f, 0.01348f, -0.28797f, -0.12125f, 0.14282f, 0.09388f, 0.18301f, 0.24048f, 0.07707f, -0.13932f, -0.13896f, -0.05071f, 0.08716f, -0.01519f, 0.09981f, -0.08055f, -0.21962f, -0.30510f, -0.18216f, -0.06957f, 0.02676f, -0.07631f, 0.06029f, 0.01262f, -0.09056f, 0.00561f, 0.07297f, -0.08328f, -0.15932f,  },
    { 0.07225f, 0.02183f, -0.06262f, -0.02878f, 0.18370f, -0.06396f, 0.07656f, -0.09466f, -0.04328f, 0.14771f, -0.03095f, -0.01236f, -0.25184f, -0.27894f, -0.01858f, -0.34272f, 0.12234f, 0.21976f, 0.21432f, 0.11445f, 0.07771f, 0.04793f, 0.01866f, 0.06186f, -0.16659f, 0.04320f, -0.06751f, -0.00614f, -0.07638f, -0.33559f,  },
    { 0.09277f, 0.14334f, 0.03111f, -0.00787f, 0.02441f, 0.22014f, 0.01985f, 0.01802f, -0.17495f, -0.19528f, -0.19135f, -0.00031f, -0.08833f, -0.11772f, -0.01005f, -0.01403f, 0.04793f, -0.05205f, 0.29851f, 0.09009f, 0.08362f, -0.08512f, -0.00308f, -0.16509f, -0.09524f, -0.12467f, 0.02129f, -0.00517f, -0.19012f, 0.24503f,  },
    { -0.15098f, 0.16669f, -0.13217f, 0.14685f, 0.17873f, 0.07271f, 0.17793f, -0.17462f, 0.04735f, -0.08589f, -0.15007f, -0.19967f, -0.17896f, -0.16158f, 0.20964f, -0.15083f, -0.18258f, -0.14449f, 0.09718f, 0.01198f, 0.01793f, -0.01504f, -0.05485f, -0.07113f, 0.03374f, 0.05296f, 0.14448f, -0.05060f, -0.10065f, 0.03867f,  },
    { -0.08767f, -0.12381f, -0.13898f, -0.09394f, -0.04507f, 0.14737f, -0.08810f, 0.02683f, 0.13648f, 0.03106f, -0.22421f, -0.20989f, -0.00916f, -0.06695f, 0.00767f, -0.10857f, 0.02624f, 0.04890f, 0.01884f, 0.19858f, 0.14659f, -0.00863f, 0.21351f, 0.03915f, 0.09676f, 0.05658f, 0.06485f, -0.16687f, -0.34425f, -0.13724f,  }
};

const float fc_bias[NUM_CLASSES] = {
    0.02743f, 0.11996f, -0.01974f, -0.10447f, -0.07635f, -0.12257f, -0.03701f, -0.02970f, 0.17197f, 0.17025f, 0.12544f, -0.15065f, -0.12173f
};

void print_seq(const char *name, const float *seq, int len)
{
    puts(name);
    for(int i = 0; i < len; i++)
    {
        printf("%.4f ", seq[i]);
    }

    putchar('\n');
}


float seq_max(const float *seq, int size)
{
    float max = seq[0];
    for(int i = 1; i < size; i++)
    {
        if(seq[i] > max)
        {
            max = seq[i];
        }
    }
    return max;
}


float argmax(const float* seq, int size)
{
    int idx = 0;
    float max = seq[0];
    for(int i = 1; i < size; i++)
    {
        if(seq[i] > max)
        {
            max = seq[i];
            idx = i;
        }
    }
    return idx;
}

int16_t nn_classifier(const float series[FEATURES][PADDED_SEQ_LEN])
{
	for(int c_idx = 0; c_idx < OUT_CHANNELS; c_idx++){
		for(int s_idx = 0; s_idx < SEQ_LEN; s_idx++)
		{
			for(int f_idx = 0; f_idx < FEATURES; f_idx++)
			{
				for(int k_idx = 0; k_idx < KERNEL_SIZE; k_idx++)
				{
					float left = series[f_idx][s_idx + k_idx];
					float right = kernel[c_idx][f_idx][k_idx];
					//float orig = output[c_idx][s_idx];

					output[c_idx][s_idx] += left * right;
                    //printf("%.1f + %.1f * %.1f = %.1f\n", orig, left,right, output[c_idx][s_idx]);
				}
			}

			// add bias term
			output[c_idx][s_idx] += bias[c_idx];
		}

		for(int i = 0; i < AFTER_POOL_LEN; i++)
		{
			// pointer arithmetic
			float val = seq_max(&(output[c_idx][i * POOL_SIZE]), POOL_SIZE);
			pool_output[c_idx][i] = val;
		}

		//relu

		for(int i = 0; i < AFTER_POOL_LEN; i++)
		{
			if(pool_output[c_idx][i] > 0)
			{
				relu_output[c_idx][i] = pool_output[c_idx][i];
			}
		}
		print_seq("seq", relu_output[c_idx], AFTER_POOL_LEN);
		putchar('\n');
	}

	for(int k = 0; k < NUM_CLASSES; k++)
	{
		for(int i = 0; i < FULLY_CONNECTED; i++)
		{
			int y = i / FULLY_CONNECTED;
			int x = i % FULLY_CONNECTED;
			float v = relu_output[y][x];
			fc_output[k] += fc[k][i] * v;
		}
		fc_output[k] += fc_bias[k];
	}
	print_seq("out", fc_output, NUM_CLASSES);

	int g = argmax(fc_output, NUM_CLASSES);
	printf("\ngesture: %d\n", g);

	return g;
}
